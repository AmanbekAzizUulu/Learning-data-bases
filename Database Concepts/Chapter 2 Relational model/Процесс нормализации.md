Процесс нормализации баз данных предназначен для устранения избыточности и предотвращения аномалий при вставке, обновлении и удалении данных. Вот пошаговое руководство по нормализации отношений (таблиц) в реляционных базах данных:

### Шаг 1: Определите все кандидатные ключи отношения

**Кандидатный ключ** — это набор атрибутов, который может однозначно идентифицировать каждую строку в таблице. Определите все возможные комбинации атрибутов, которые могут быть ключами.

### Шаг 2: Определите все функциональные зависимости в отношении

**Функциональная зависимость** — это связь между атрибутами, где значение одного атрибута (или набора атрибутов) определяет значение другого атрибута (или набора атрибутов). Определите все такие зависимости для вашей таблицы.

### Шаг 3: Проверьте детерминанты функциональных зависимостей

1. **Анализ детерминантов**:
   - Детерминант — это атрибут (или набор атрибутов), который определяет другие атрибуты в функциональной зависимости. Например, в зависимости `A → B`, `A` является детерминантом.
   - Если детерминант не является кандидатным ключом, это указывает на то, что таблица не является хорошо сформированной и требует нормализации.

2. **Создание новых отношений**:
   - **Создайте новую таблицу** для каждого набора атрибутов, указанных в функциональной зависимости. Эта новая таблица будет содержать детерминант как первичный ключ.
   - **Определите первичный ключ** для новой таблицы на основе детерминанта функциональной зависимости.
   - **Добавьте детерминант как внешний ключ** в оригинальную таблицу, чтобы поддерживать связь между таблицами.
   - **Создайте ограничение ссылочной целостности** между оригинальной таблицей и новой таблицей, чтобы обеспечить согласованность данных.

### Шаг 4: Повторяйте шаг 3 до тех пор, пока каждый детерминант каждой таблицы не станет кандидатным ключом

**Повторение процесса**:
- Продолжайте процесс нормализации до тех пор, пока все детерминанты в каждой таблице не будут являться кандидатными ключами. Это гарантирует, что каждая таблица будет правильно нормализована, устранив избыточность и аномалии.

### Пример

Допустим, у вас есть таблица `StudentCourses`, содержащая следующие атрибуты: `StudentID`, `CourseID`, `InstructorName`, `InstructorOffice`.

**Шаг 1**: Определите кандидатные ключи.
- Допустим, `StudentID` и `CourseID` вместе являются кандидатным ключом, потому что вместе они однозначно идентифицируют каждую строку.

**Шаг 2**: Определите функциональные зависимости.
- `StudentID, CourseID → InstructorName, InstructorOffice`
- `InstructorName → InstructorOffice`

**Шаг 3**: Проверка детерминантов.
- `InstructorName` определяет `InstructorOffice`, но `InstructorName` не является кандидатным ключом в таблице `StudentCourses`.

**Шаг 4**: Нормализация.
- Создайте новую таблицу `Instructors`:
  ```sql
  CREATE TABLE Instructors (
      InstructorName VARCHAR PRIMARY KEY,
      InstructorOffice VARCHAR
  );
  ```
- Перенесите `InstructorName` и `InstructorOffice` в новую таблицу `Instructors`.
- Оставьте в оригинальной таблице `StudentCourses` только `StudentID`, `CourseID`, и `InstructorName`.
- Добавьте внешний ключ в `StudentCourses`:
  ```sql
  ALTER TABLE StudentCourses
  ADD CONSTRAINT fk_instructor
  FOREIGN KEY (InstructorName) REFERENCES Instructors (InstructorName);
  ```

После нормализации таблицы могут выглядеть следующим образом:

**Таблица `Instructors`**:

| InstructorName | InstructorOffice |
|----------------|-------------------|
| Dr. Smith      | Room 101          |
| Dr. Jones      | Room 202          |

**Таблица `StudentCourses`**:

| StudentID | CourseID | InstructorName |
|-----------|----------|----------------|
| 1         | 1001     | Dr. Smith      |
| 2         | 1002     | Dr. Jones      |

Этот процесс гарантирует, что каждая таблица будет удовлетворять нормальным формам и обеспечивать целостность данных.