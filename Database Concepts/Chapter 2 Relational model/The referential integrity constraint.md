**The referential integrity constraint** (ограничение ссылочной целостности) — это тип ограничения в реляционной базе данных, который обеспечивает корректность и согласованность ссылок между таблицами. Оно гарантирует, что значения внешнего ключа (Foreign Key) в одной таблице всегда ссылаются на существующие значения в другой таблице, поддерживая целостность связей между данными.

### Основные аспекты ограничения ссылочной целостности

1. **Внешний ключ (Foreign Key)**:
   - Внешний ключ — это атрибут или набор атрибутов в дочерней таблице, который ссылается на первичный ключ (или уникальный ключ) в родительской таблице.
   - Внешний ключ обеспечивает связь между двумя таблицами.

2. **Согласованность данных**:
   - Гарантирует, что значения внешнего ключа в дочерней таблице всегда ссылаются на существующие значения в родительской таблице.
   - Предотвращает создание "осиротевших" записей, которые ссылаются на несуществующие записи.

### Пример

Рассмотрим две таблицы: `Orders` и `Customers`. Таблица `Orders` содержит информацию о заказах, а таблица `Customers` содержит информацию о клиентах. Мы можем установить ограничение ссылочной целостности, чтобы каждый заказ ссылался на существующего клиента.

**Таблица Customers**:

```sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    Name VARCHAR(100)
);
```

**Таблица Orders**:

```sql
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);
```

В этом примере:
- `CustomerID` в таблице `Orders` является внешним ключом, который ссылается на `CustomerID` в таблице `Customers`.
- Значение `CustomerID` в таблице `Orders` должно существовать в таблице `Customers`.

### Поддержание ссылочной целостности

1. **Вставка (INSERT)**:
   - Нельзя вставить строку в таблицу `Orders` с `CustomerID`, который не существует в таблице `Customers`.

2. **Обновление (UPDATE)**:
   - Нельзя обновить значение `CustomerID` в таблице `Orders` на значение, которого нет в таблице `Customers`.

3. **Удаление (DELETE)**:
   - Нельзя удалить запись из таблицы `Customers`, если на нее ссылаются строки в таблице `Orders`, если не указаны каскадные операции.

### Каскадные операции

Для управления целостностью при удалении или обновлении данных могут быть использованы каскадные операции:

1. **ON DELETE CASCADE**:
   - При удалении записи из родительской таблицы автоматически удаляются все связанные записи в дочерней таблице.

2. **ON UPDATE CASCADE**:
   - При обновлении значения первичного ключа в родительской таблице автоматически обновляются все соответствующие значения внешнего ключа в дочерней таблице.

3. **ON DELETE SET NULL**:
   - При удалении записи из родительской таблицы все соответствующие значения внешнего ключа в дочерней таблице устанавливаются в NULL.

4. **ON UPDATE SET NULL**:
   - При обновлении значения первичного ключа в родительской таблице все соответствующие значения внешнего ключа в дочерней таблице устанавливаются в NULL.

5. **ON DELETE RESTRICT / NO ACTION**:
   - Запрещает удаление записи из родительской таблицы, если на нее ссылаются записи в дочерней таблице.

6. **ON UPDATE RESTRICT / NO ACTION**:
   - Запрещает обновление значения первичного ключа в родительской таблице, если на него ссылаются записи в дочерней таблице.

### Пример определения внешнего ключа с каскадными операциями в SQL

```sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    Name VARCHAR(100)
);

CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
```

В этом примере:
- Если запись в `Customers` удаляется или обновляется, то соответствующие записи в `Orders` также будут автоматически удалены или обновлены, благодаря каскадным операциям.

### Важность ограничения ссылочной целостности

- **Целостность данных**: Гарантирует, что ссылки между таблицами остаются корректными и согласованными.
- **Поддержание связи**: Обеспечивает правильность и согласованность связей между таблицами, предотвращая осиротевшие записи.
- **Упрощение управления данными**: Упрощает управление связанными данными и поддерживает их целостность при выполнении операций вставки, обновления и удаления.
---

**Referential integrity constraint** (ограничение ссылочной целостности) в реляционных базах данных гарантирует, что связи между таблицами остаются корректными и согласованными. Оно обеспечивает правильность и целостность данных при работе с таблицами, связанными отношением "родитель-ребенок".

### Основные аспекты ограничения ссылочной целостности

1. **Внешний ключ (Foreign Key)**:
   - Это ключ, который используется для установления и обеспечения связи между двумя таблицами.
   - Внешний ключ в дочерней таблице ссылается на первичный ключ или уникальный ключ в родительской таблице.

2. **Целостность данных**:
   - Обеспечивает, что значения во внешнем ключе всегда существуют в соответствующей записи родительской таблицы.
   - Например, если внешняя таблица содержит ссылки на записи родительской таблицы, то каждая ссылка должна указывать на существующую запись.

### Пример

Рассмотрим две таблицы: `Orders` и `Customers`. Таблица `Orders` содержит информацию о заказах, а таблица `Customers` содержит информацию о клиентах. Мы можем установить ограничение ссылочной целостности, чтобы каждый заказ ссылался на существующего клиента.

**Таблица Customers**:

| CustomerID | Name   |
|------------|--------|
| 1          | Alice  |
| 2          | Bob    |

**Таблица Orders**:

| OrderID | CustomerID | Product  |
| ------- | ---------- | -------- |
| 101     | 1          | Widget A |
| 102     | 2          | Widget B |
| 103     | 3          | Widget C |

В этом примере `CustomerID` в таблице `Orders` является внешним ключом, который ссылается на `CustomerID` в таблице `Customers`.

### Поддержание ссылочной целостности

1. **Вставка (INSERT)**:
   - Нельзя вставить строку в таблицу `Orders` с `CustomerID`, который не существует в таблице `Customers`.

2. **Обновление (UPDATE)**:
   - Нельзя обновить значение `CustomerID` в таблице `Orders` на значение, которого нет в таблице `Customers`.

3. **Удаление (DELETE)**:
   - Нельзя удалить запись из таблицы `Customers`, если на нее ссылаются строки в таблице `Orders`, если не указаны каскадные операции.

### Каскадные операции

Для управления целостностью при удалении или обновлении данных могут быть использованы каскадные операции:

1. **ON DELETE CASCADE**:
   - При удалении записи из родительской таблицы автоматически удаляются все связанные записи в дочерней таблице.

2. **ON UPDATE CASCADE**:
   - При обновлении значения первичного ключа в родительской таблице автоматически обновляются все соответствующие значения внешнего ключа в дочерней таблице.

3. **ON DELETE SET NULL**:
   - При удалении записи из родительской таблицы все соответствующие значения внешнего ключа в дочерней таблице устанавливаются в NULL.

4. **ON UPDATE SET NULL**:
   - При обновлении значения первичного ключа в родительской таблице все соответствующие значения внешнего ключа в дочерней таблице устанавливаются в NULL.

5. **ON DELETE RESTRICT / NO ACTION**:
   - Запрещает удаление записи из родительской таблицы, если на нее ссылаются записи в дочерней таблице.

6. **ON UPDATE RESTRICT / NO ACTION**:
   - Запрещает обновление значения первичного ключа в родительской таблице, если на него ссылаются записи в дочерней таблице.

### Пример определения внешнего ключа в SQL

```sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    Name VARCHAR(100)
);

CREATE TABLE Orders (
    OrderID    INT PRIMARY KEY,
    CustomerID INT,
    Product    VARCHAR(100),
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
```

В этом примере, если запись в `Customers` удаляется или обновляется, то соответствующие записи в `Orders` также будут автоматически удалены или обновлены, благодаря каскадным операциям.