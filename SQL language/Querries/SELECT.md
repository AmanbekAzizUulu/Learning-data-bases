[Learn SQL Syntax](https://www.geeksforgeeks.org/sql-except-clause/?ref=lbp)
## Выборка всех данных из таблицы

Для того чтобы отобрать все данные из таблицы используется SQL запрос следующей структуры: 

- ключевое слово **SELECT**; 
- символ « * »; 
- ключевое слово **FROM**; 
- имя таблицы.

Результатом является таблица, в которую включены все строки и столбцы указанной в запросе таблицы.

**Пример**

Выбрать все записи таблицы `book`.

_Запрос:_

```sql
SELECT * FROM book;
```

---
## Выборка отдельных столбцов

Для того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: 

- ключевое слово **SELECT** ; 
- список столбцов таблицы через запятую; 
- ключевое слово **FROM** ; 
- имя таблицы.

Результатом является таблица, в которую включены все данные из указанных после **SELECT** столбцов исходной таблицы.

**Пример**

Выбрать названия книг и их количества из таблицы `**book**` .

_Запрос:_

```sql
SELECT title, amount FROM book;
```

_Результат:_

```sql
+-----------------------+--------+ 
|title                  | amount |
+-----------------------+--------+ 
| Мастер и Маргарита    | 3      | 
| Белая гвардия         | 5      | 
| Идиот                 | 10     | 
| Братья Карамазовы     | 2      | 
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
```

**Пояснение.** Чтобы посмотреть, как работает запрос примера, скопируйте его код в окно для ввода и нажмите на черную кнопку **Запустить код**. После запуска выведется результат запроса, который можно сравнить с приведенным образцом. Задание

---
## Присвоение новых имен столбцам при формировании выборки

Для того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые названия в результате выборки используется SQL запрос следующей структуры: 

- ключевое слово **SELECT**; 
- имя столбца;
- ключевое слово **AS**; 
- новое название столбца (можно русскими буквами), выводимое в результате запроса, но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, **количество_книг**; 
- запятая; 
- имя столбца; 
- ....
- ключевое слово **FROM**; 
- имя таблицы.

В одном запросе можно использовать и имена столбцов из таблицы, и новые названия.

Результатом является таблица, в которую включены все данные из указанных после **SELECT** столбцов исходной таблицы. Каждому столбцу в результате запроса присваивается новое имя, заданное после **AS**, или столбец получает имя столбца исходной таблицы, если **AS** отсутствует.

**Пример**

Выбрать все названия книг и их количества из таблицы `**book**` , для столбца `**title**` задать новое имя `**Название**`.

_Запрос:_

```sql
SELECT title AS Название, amount 
FROM book;
```

_Результат:_

```sql
+-----------------------+--------+
| Название              | amount |
+-----------------------+--------+ 
| Мастер и Маргарита    | 3      |
| Белая гвардия         | 5      | 
| Идиот                 | 10     |
| Братья Карамазовы     | 2      |
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
```

---
## Выборка данных с созданием вычисляемого столбца

С помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в списке полей после оператора **SELECT** указывается выражение и задается имя.

Выражение может включать 
	- имена столбцов, 
	- константы, 
	- знаки операций, 
	- встроенные функции.

Результатом является таблица, в которую включены все данные из указанных после **SELECT** столбцов, а также новый столбец, в каждой строке которого вычисляется заданное выражение.

**Пояснение от слушателя**. Можно осуществлять арифметические и логические вычисления над целым столбцом, результатом будет новый столбец.

**Пример**

Вывести всю информацию о книгах, а также для каждой позиции посчитать ее стоимость (произведение цены на количество). Вычисляемому столбцу дать имя **total** .

_Запрос:_

```sql
SELECT title, author, price, amount, 
     price * amount AS total 
FROM book;
```

_Результат:_

```sql
+-----------------------+------------------+--------+--------+---------+ 
| title                 | author           | price  | amount | total   | 
+-----------------------+------------------+--------+--------+---------+ 
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 2012.97 | 
| Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | 2702.50 | 
| Идиот                 | Достоевский Ф.М. | 460.00 | 10     | 4600.00 | 
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 1598.02 | 
| Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | 9750.00 |
+-----------------------+------------------+--------+--------+---------+ 
```

---
## Выборка данных, вычисляемые столбцы, математические функции

В SQL реализовано множество  [математических функций](https://docs.microsoft.com/ru-ru/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver15) для работы с числовыми данными. В таблице приведены некоторые из них.

| **Функция**   | **Описание**                                                                                                     | **Пример**                              |
| ------------- | ---------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| `CEILING(x) ` | возвращает наименьшее целое число, большее или равное **x**  <br>(округляет до целого числа в большую сторону)   | `CEILING(4.2)=5   CEILING(-5.8)=-5`     |
| `ROUND(x, k)` | округляет значение **x** до **k** знаков после запятой,  <br>если **k** не указано – **x** округляется до целого | `ROUND(4.361)=4   ROUND(5.86592,1)=5.9` |
| `FLOOR(x)`    | возвращает наибольшее целое число, меньшее или равное **x**  <br>(округляет до  целого числа в меньшую сторону)  | `FLOOR(4.2)=4   FLOOR(-5.8)=-6`         |
| `POWER(x, y)` | возведение **x** в степень **y**                                                                                 | `POWER(3,4)=81.0`                       |
| `SQRT(x)`     | квадратный корень из **x**                                                                                       | `SQRT(4)=2.0   SQRT(2)=1.41...`         |
| `DEGREES(x)`  | конвертирует значение **x** из радиан в градусы                                                                  | `DEGREES(3) = 171.8...`                 |
| `RADIANS(x)`  | конвертирует значение **x** из градусов в радианы                                                                | `RADIANS(180)=3.14...`                  |
| `ABS(x)`      | модуль числа **x**                                                                                               | `ABS(-1) = 1   ABS(1) = 1`              |
| `PI()`        | pi = 3.1415926...                                                                                                |                                         |

**Пояснение.**   Существуют разные способы округления чисел. В SQL реализовано **математическое округление**. Для округления вещественного числа нужно в записи числа выбрать разряд в дробной части, до которого производится округление. Цифра, записанная в выбранном разряде: не меняется, если следующая за ней справа цифра - 0, 1, 2, 3 или 4; увеличивается на единицу, если следующая за ней справа цифра - 5, 6, 7, 8 или 9.

**Пример** 

Для каждой книги из таблицы **book** вычислим налог на добавленную стоимость (имя столбца **tax**) , который включен в цену и составляет k = 18%,  а также цену книги (**price_tax**) без него. Формулы для вычисления:

$$ \text{tax} = \frac{\text{price} \times \frac{k}{100}}{1 + \frac{k}{100}} $$ $$ \text{price\_tax} = \frac{\text{price}}{1 + \frac{k}{100}} $$
*Значение НДС в 18% взято для ПРИМЕРА, чтобы показать как использовать функции округления.*

**Пояснение от [Андрея Виноградова](https://stepik.org/users/137112290)**:****

Эта формула НДС отвечает на вопрос "Какую сумму увеличили на 18%, чтобы получить текущее значение"

_Запрос:_

```sql
SELECT title, price, 
    (price*18/100)/(1+18/100) AS tax, 
    price/(1+18/100) AS price_tax 
FROM book;
```

_Результат:_

```sql
+-----------------------+--------+----------------+------------+
| title                 | price  | tax            | price_tax  |
+-----------------------+--------+----------------+------------+
| Мастер и Маргарита    | 670.99 | 102.3544067797 | 568.635593 |
| Белая гвардия         | 540.50 | 82.4491525424  | 458.050847 |
| Идиот                 | 460.00 | 70.1694915254  | 389.830508 |
| Братья Карамазовы     | 799.01 | 121.8828813559 | 677.127119 |
| Стихотворения и поэмы | 650.00 | 99.1525423729  | 550.847458 |
+-----------------------+--------+----------------+------------+
```

Сумма налога и цена книги без налога – это деньги, поэтому количество знаков после запятой у этих чисел должно быть 2. Следовательно необходимо округлить полученные значения.

_Запрос_:

```sql
SELECT title, 
    price, 
    ROUND((price*18/100)/(1+18/100),2) AS tax, 
    ROUND(price/(1+18/100),2) AS price_tax 
FROM book;
```

_Результат:_

```sql
+-----------------------+--------+--------+-----------+
| title                 | price  | tax    | price_tax |
+-----------------------+--------+--------+-----------+
| Мастер и Маргарита    | 670.99 | 102.35 | 568.64    |
| Белая гвардия         | 540.50 | 82.45  | 458.05    |
| Идиот                 | 460.00 | 70.17  | 389.83    |
| Братья Карамазовы     | 799.01 | 121.88 | 677.13    |
| Стихотворения и поэмы | 650.00 | 99.15  | 550.85    |
+-----------------------+--------+--------+-----------+
```

---
## Выборка данных, вычисляемые столбцы, логические функции

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция `IF()`:

```sql
IF(логическое_выражение, выражение_1, выражение_2)
```

Функция вычисляет `логическое_выражение,` если оно истина – в поле заносится значение `выражения_1`, в противном случае –  значение `выражения_2.` Все три параметра `IF()` являются обязательными.

Допускается использование вложенных функций, вместо `выражения_1` или `выражения_2` может стоять новая функция **IF**.

**Пример** 

Для каждой книги из таблицы **book** установим скидку следующим образом: если количество книг меньше 4, то скидка будет составлять 50% от цены, в противном случае 30%.

_Запрос:_

```sql
SELECT title, amount, price, 
    IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;
```

_Результат:_

```sql
+-----------------------+--------+--------+---------+
| title                 | amount | price  | sale    |
+-----------------------+--------+--------+---------+
| Мастер и Маргарита    | 3      | 670.99 | 335.495 |
| Белая гвардия         | 5      | 540.50 | 378.350 |
| Идиот                 | 10     | 460.00 | 322.000 |
| Братья Карамазовы     | 2      | 799.01 | 399.505 |
| Стихотворения и поэмы | 15     | 650.00 | 455.000 |
+-----------------------+--------+--------+---------+
```

Цена по скидке должна отображаться с двумя знаками после запятой, добавим в запрос округление:

```sql
SELECT title, amount, price, 
    ROUND(IF(amount<4, price*0.5, price*0.7),2) AS sale
FROM book;
```

_Результат:_

```sql
+-----------------------+--------+--------+--------+
| title                 | amount | price  | sale   |
+-----------------------+--------+--------+--------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 |
| Белая гвардия         | 5      | 540.50 | 378.35 |
| Идиот                 | 10     | 460.00 | 322.00 |
| Братья Карамазовы     | 2      | 799.01 | 399.51 |
| Стихотворения и поэмы | 15     | 650.00 | 455.00 |
+-----------------------+--------+--------+--------+
```

**Пример**

Усложним вычисление скидки в зависимости от количества книг. Если количество книг меньше 4 – то скидка 50%, меньше 11 – 30%, в остальных случаях – 10%. И еще укажем какая именно скидка на каждую книгу.

Запрос:

```sql
SELECT title, amount, price,
    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,
    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка
FROM book;
```

_Результат:_

```sql
+-----------------------+--------+--------+--------+-------------+
| title                 | amount | price  | sale   | Ваша_скидка |
+-----------------------+--------+--------+--------+-------------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 | скидка 50%  |
| Белая гвардия         | 5      | 540.50 | 378.35 | скидка 30%  |
| Идиот                 | 10     | 460.00 | 322.00 | скидка 30%  |
| Братья Карамазовы     | 2      | 799.01 | 399.51 | скидка 50%  |
| Стихотворения и поэмы | 15     | 650.00 | 585.00 | скидка 10%  |
+-----------------------+--------+--------+--------+-------------+
```

---
## Выборка данных по условию

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово `WHERE` и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.

Логическое выражение может включать **операторы сравнения** (
	равно «**=**», 
	не равно «**<>**», 
	больше «**>**», 
	меньше «**<**», 
	больше или равно«**>=**», 
	меньше или равно «**<=**») и 
	выражения, допустимые в SQL.

**Пример**

Вывести название и цену тех книг, цены которых меньше 600 рублей.

_Запрос:_

```sql
SELECT title, price 
FROM book
WHERE price < 600;
```

_Результат:_

```sql
+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
```

 **Пример**

Вывести название, автора  и стоимость (цена умножить на количество) тех книг, стоимость которых больше 4000 рублей

_Запрос:_

```sql
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
```

_Результат:_

```sql
+-----------------------+------------------+---------+
| title                 | author           | total   |
+-----------------------+------------------+---------+
| Идиот                 | Достоевский Ф.М. | 4600.00 |
| Стихотворения и поэмы | Есенин С.А.      | 9750.00 |
+-----------------------+------------------+---------+
```

**Пояснение**

В логическом выражении после **WHERE** нельзя использовать названия столбцов, присвоенные им с помощью **AS**,  так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос.

---

## **Выборка данных, логические операции**

 Логическое выражение после ключевого слова `WHERE` кроме операторов сравнения  и выражений может включать  **логические операции** (И «**and**», ИЛИ «**or**», НЕ «**not**») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

**Пример**

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

_Запрос:_

```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

_Результат:_

```sql
+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+
```

 **Пример**

Вывести название, цену  тех книг, которые написал Булгаков или Есенин, ценой больше 600 рублей

_Запрос:_

```sql
SELECT title, author, price 
FROM book
WHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;
```

_Результат:_

```sql
+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
```

**Пояснение.**

В данном запросе обязательно нужно поставить скобки, так как без них сначала вычисляется  `author = 'Есенин С.А.' and price > 600,` а потом уже выражение через `or`. Без скобок были бы отобраны все книги Булгакова и те книги Есенина, цена которых больше 600.

_Запрос:_

```sql
SELECT title, author, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Есенин С.А.' AND price > 600;
```

_Результат (сравните с предыдущим):_

```sql
+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Белая гвардия         | Булгаков М.А. | 540.50 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
```

---
## Выборка данных, операторы BETWEEN, IN

 Логическое выражение после ключевого слова `WHERE` может включать операторы  **`BETWEEN`** и **`IN`**. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем **NOT**, **AND**, **OR**.

Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

**Пример**

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

_Запрос:_

```sql
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
```

_Результат:_

```sql
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
```

Оператор  `IN`  позволяет выбрать данные, соответствующие значениям из списка.

**Пример**

Выбрать названия и цены книг, написанных Булгаковым или Достоевским.

_Запрос:_

```sql
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```

_Результат:_

```sql
+--------------------+--------+
| title              | price  |
+--------------------+--------+
| Мастер и Маргарита | 670.99 |
| Белая гвардия      | 540.50 |
| Идиот              | 460.00 |
| Братья Карамазовы  | 799.01 |
+--------------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

---
## Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу. Если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:

- названием столбца;
- номером столбца;
- именем столбца (указанным после `AS`).

**Пример**

Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.

_Запрос:_

```sql
SELECT title, author, price
FROM book
ORDER BY title;
```

_Результат:_

```sql
+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+
```

Аналогичный результат получится при использовании запроса:

```sql
SELECT title, author, price
FROM book
ORDER BY 1;
```

**Пример**

Вывести автора, название и количество книг, в отсортированном в алфавитном порядке по автору и по убыванию количества, для тех книг, цены которых меньше 750 рублей.

_Запрос:_

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
```

_Результат:_

```sql
+------------------+-----------------------+------------+
| author           | title                 | Количество |
+------------------+-----------------------+------------+
| Булгаков М.А.    | Белая гвардия         | 5          |
| Булгаков М.А.    | Мастер и Маргарита    | 3          |
| Достоевский Ф.М. | Идиот                 | 10         |
| Есенин С.А.      | Стихотворения и поэмы | 15         |
+------------------+-----------------------+------------+
```

Можно использовать другие варианты записи запроса:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
```

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;
```

**Важно!** Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК.

---
## Выборка данных, оператор LIKE

Оператор `LIKE` используется для сравнения строк. В отличие от операторов отношения равно (**=**) и не равно (**<>**), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать **обычные символы** и **символы-шаблоны**. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

| Символ-шаблон         | Описание                                         | Пример                                                                                                                                       |
| --------------------- | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------- |
| **%**                 | Любая строка, содержащая ноль или более символов | `SELECT * FROM book WHERE author LIKE '%М.%'`  <br>выполняет поиск и выдает все книги, инициалы авторов которых содержат «_М._»              |
| **_** (подчеркивание) | Любой одиночный символ                           | `SELECT * FROM book WHERE title LIKE 'Поэм_'`  <br>выполняет поиск и выдает все книги, названия которых либо «_Поэма_», либо «_Поэмы_» и пр. |

**Пример 1**

Вывести названия книг, начинающихся с буквы «_Б_».

_Запрос:_

```sql
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```

_Результат:_

```sql
+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+
```

**Пояснение**

**Пример 2**

Вывести название книг, состоящих ровно из 5 букв.

_Запрос:_

```sql
SELECT title FROM book 
WHERE title LIKE "_____"
```

_Результат:_

```sql
+-------+
| title |
+-------+
| Идиот |
| Поэмы |
+-------+
```

**Пояснение**

**Пример 3**

Вывести книги, название которых длиннее 5 символов:

_Запрос:_

```sql
SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
```

_Результат:_

```sql
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Белая гвардия         |
| Братья Карамазовы     |
| Стихотворения и поэмы |
| Дети полуночи         |
| Лирика                |
| Капитанская дочка     |
+-----------------------+
```

**Пояснение**  

Для того чтобы вывести названия, состоящие из любого количества символов после`**LIKE**` можно использовать шаблон **"%"**, с помощью которого отбираются строки, состоящие из любого количества символов, в том числе и "пустые", поскольку % заменяет любое количество символов, в том числе и нулевое.

Чтобы указать, что в названии должен быть хотя бы один символ, можно использовать один из эквивалентных шаблонов:

-  **"_%"** - сначала идет символ, а за ним любое количество символов;
- **"%_"** - сначала идет любое количество символов, а затем обязательный символ;
- **"%_%"** - сначала идет любое количество символов, потом обязательный символ, а за ним любое количество символов.

**Пример 4**

Вывести названия книг, которые содержат букву **"и"** как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания.

 _Запрос:_

```sql
SELECT title FROM book 
WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */

```

_Результат:_

```sql
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Стихотворения и поэмы |
+-----------------------+
```

**Пояснение**

Слово "и" может располагаться в названии в следующих позициях (при условии, что слова отделяются друг от друга пробелами):

-  в середине -  **"_% и _%"** - сначала идет любое количество символов (один обязательный), потом обязательный пробел, а за ним "и", снова обязательный пробел, и наконец любое количество символов (один обязательный);
- в начале - **"и _%"** - сначала идет "и", обязательный пробел и любое количество символов (один обязательный);
- в конце - **"_% и"** - сначала идет любое количество символов, затем обязательный пробел и буква "и":
- одно слово в названии - **"и"**.

Вместо "**_%"** можно использовать эквивалентные шаблоны **"%_"** и **"%_%"** .

В качестве обязательного символа ( "_"), может быть и пробел, но, к сожалению, шаблоны для **LIKE** не позволяют исключить какой-то символ. Это можно сделать только с помощью регулярных выражений (будут рассмотрены в уроке 3.5)

**Пример 5**

Вывести названия книг, которые состоят ровно из одного слова, если считать, что слова в названии отделяются друг от друга пробелами .

 _Запрос:_

```sql
SELECT title FROM book 
WHERE title NOT LIKE "% %";    
```

_Результат:_

```sql
+--------+
| title  |
+--------+
| Идиот  |
| Лирика |
| Поэмы  |
+--------+
```

**Пояснение**: Отсутствие пробела в названии означает, что оно состоит из одного слова. Чтобы это проверить используется оператор **NOT LIKE**, который в данном случае отберет все названия, в которых нет пробелов.

```
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       |                       | Иванов С.С.      | 50.00  | 10     |
| 7       | Дети полуночи         | Рушди Салман     | 950.00 | 5      |
| 8       | Лирика                | Гумилев Н.С.     | 460.00 | 10     |
| 9       | Поэмы                 | Бехтерев С.С.    | 460.00 | 10     |
| 10      | Капитанская дочка     | Пушкин А.С.      | 520.50 | 7      |
+---------+-----------------------+------------------+--------+--------+
```

---
## Выбор уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово `DISTINCT`, которое размещается сразу после `SELECT`.

**Пример**

Выбрать различных авторов, книги которых хранятся в таблице **book**.

_Запрос:_

```sql
SELECT DISTINCT author
FROM book;
```

_Результат:_

```sql
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

Другой способ – использование оператора `GROUP BY`, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после `GROUP BY` .

С помощью `GROUP BY` можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании `DISTINCT`.

_Запрос:_

```sql
SELECT  author
FROM book
GROUP BY author;
```

---
## Выборка данных, групповые функции SUM и COUNT

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

```
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```

1. В таблице **book** определяются строки, в которых в столбце **author** одинаковые значения:

![](https://ucarecdn.com/2c9cc54f-b3b0-4388-8443-bcf590176622/)

Получили 3 различные группы:

- **группа I** объединяет две записи, у которых в столбце **author** значение Булгаков М.А.;
- **группа II** объединяет три записи, у которых в столбце **author** значение Достоевский Ф.М.;
- **группа III** объединяет одну запись, у которой в столбце **author** значение Есенин С.А.

2. Вместо каждой группы в результирующий запрос включается  одна запись. Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это **author**):

![](https://ucarecdn.com/8265a790-2164-44ee-882a-d2ef67fa75d4/)

3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция `SUM()`, а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае **amount**):

![](https://ucarecdn.com/8ef972d9-842b-438c-a4c5-e13a0a17d9fb/)

4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция `COUNT()`, в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает **COUNT()**, если в группе есть пустые значения):

![](https://ucarecdn.com/708aa6d7-f879-41b4-8030-103e4b43754e/)

**Пример**

Посчитать, сколько экземпляров книг каждого автора хранится на складе.

_Запрос:_

```sql
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```

_Результат:_

```sql
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```

**Примечание**

Обратите внимание, что в качестве названия вычисляемого столбца в результирующей таблице используется выражение. Рекомендуется всем  вычисляемым столбцам давать имя.

**Пример**

Посчитать, сколько различных книг каждого автора хранится на складе.

Только для этого примера в таблицу `**book**` добавлена запись с пустыми значениями в столбцах `**amount**` и `**price**`:

```sql
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
| 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
| 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 7       | Черный человек        | Есенин С.А.      | Null   | Null   |
+---------+-----------------------+------------------+--------+--------+
```

_Запрос:_

```sql
/* чтобы проверить запрос, добавьте в таблицу строку */
INSERT INTO book (title, author, price, amount) VALUES ('Черный человек','Есенин С.А.', Null, Null);

SELECT author, COUNT(author), COUNT(amount), COUNT(*)
FROM book
GROUP BY author;
```

_Результат:_

```sql
+------------------+---------------+---------------+----------+
| author           | COUNT(author) | COUNT(amount) | COUNT(*) |
+------------------+---------------+---------------+----------+
| Булгаков М.А.    | 2             | 2             | 2        |
| Достоевский Ф.М. | 3             | 3             | 3        |
| Есенин С.А.      | 2             | 1             | 2        |
+------------------+---------------+---------------+----------+
```

Из таблицы с результатами запроса видно, что функцию `**COUNT()**` можно применять к любому столбцу, в том числе можно использовать и `*****`, если таблица не содержит пустых значений. Если же в столбцах есть значения `**Null**`, (для группы по автору Есенин в нашем примере), то

- `**COUNT(*)**` —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением `**NULL**`;
- `**COUNT(имя_столбца)**` — возвращает количество записей конкретного столбца (только `**NOT NULL**`), относящихся к группе.

**ВАЖНО.**

1. Если столбец указан в `SELECT`  **БЕЗ** применения групповой функции, то он обязательно должен быть указан и в`GROUP BY.`Иначе получим ошибку.
2. Между названием функции и скобкой **НЕЛЬЗЯ СТАВИТЬ ПРОБЕЛ**. Это особенность платформы.

---
## Выборка данных c вычислением, групповые функции

В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

**Пример**

Вывести суммарную стоимость книг каждого автора.

_Запрос:_

```sql
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```

_Результат:_

```sql
+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Булгаков М.А.    | 4715.47   |
| Достоевский Ф.М. | 11802.03  |
| Есенин С.А.      | 9750.00   |
+------------------+-----------+
```

Групповые функции могут быть элементами выражений. Например, при вычислении средней стоимости книг каждого автора на предыдущем шаге получились значения с шестью знаками после запятой. А поскольку это деньги, значения нужно округлить до 2 знаков после запятой.

 **Пример**

Найти среднюю цену книг каждого автора.

_Запрос:_

```sql
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```

_Результат:_

```sql
+------------------+--------------+
| author           | Средняя_цена |
+------------------+--------------+
| Булгаков М.А.    | 605.75       |
| Достоевский Ф.М. | 579.84       |
| Есенин С.А.      | 650.00       |
+------------------+--------------+
```

---
## Вычисления по таблице целиком

Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова SELECT указывается групповая функция для выражения или имени столбца, а ключевые слова `GROUP BY` опускаются.

**Пример**

Посчитать количество экземпляров книг на складе.

_Запрос:_

```sql
SELECT SUM(amount) AS Количество
FROM book;
```

_Результат:_

```sql
+------------+
| Количество |
+------------+
| 46         |
+------------+ 
```

Результатом таких запросов является единственная строка с вычисленными по таблице значениями.

 **Пример**

Посчитать общее количество экземпляров книг на складе и их стоимость .

_Запрос:_

```sql
SELECT SUM(amount) AS Количество, 
    SUM(price * amount) AS Стоимость
FROM book;
```

_Результат:_

```sql
+------------+-----------+
| Количество | Стоимость |
+------------+-----------+
| 46         | 26267.50  |
+------------+-----------+
```

---
## Выборка данных по условию, групповые функции

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

**Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.

_Запрос:_

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
```

_Результат:_

```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
```

Также в запросах с группировкой можно сортировать данные.

 **Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.

_Запрос:_

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
```

_Результат:_

```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Есенин С.А.      | 650.00           | 650.00            |
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

**Пояснение**

При указании столбца, по которому выполняется сортировка, если столбцу присвоено имя  с помощью `AS`, можно использовать это имя.

---
## Выборка данных по условию, групповые функции, WHERE и HAVING

`WHERE` и `HAVING` могут использоваться в одном запросе. При этом необходимо учитывать **порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ**:

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

Сначала определяется таблица, из которой выбираются данные (`FROM`), затем из этой таблицы отбираются записи в соответствии с условием  `WHERE`, выбранные данные агрегируются (`GROUP BY`),  из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`. Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после `ORDER BY`.

**Важно!** Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в `**WHERE**` нельзя использовать имена выражений из `**SELECT**`. Просто `**SELECT**` выполняется компилятором позже, чем `**WHERE**`, поэтому ему неизвестно, какое там выражение написано.

**Пример**

Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

_Результат:_

```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

Другим способом решения примера является запрос:

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```

Не смотря на то что результат будет одинаковым, так делать **не рекомендуется**. «Потому что как написано - запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает...».